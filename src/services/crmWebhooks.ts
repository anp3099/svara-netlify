// Webhook Management Service for CRM Integrations\nimport { blink } from '../blink/client';\nimport { crmOAuthService } from './crmOAuth';\n\nexport interface WebhookConfig {\n  id: string;\n  userId: string;\n  provider: string;\n  eventType: string;\n  callbackUrl: string;\n  secret?: string;\n  isActive: boolean;\n  createdAt: Date;\n  lastTriggered?: Date;\n  triggerCount: number;\n  errorCount: number;\n}\n\nexport interface WebhookEvent {\n  id: string;\n  webhookId: string;\n  eventType: string;\n  payload: any;\n  signature?: string;\n  processed: boolean;\n  processingError?: string;\n  receivedAt: Date;\n  processedAt?: Date;\n}\n\nexport interface WebhookProcessingResult {\n  success: boolean;\n  recordsProcessed: number;\n  recordsCreated: number;\n  recordsUpdated: number;\n  errors: string[];\n  duration: number;\n}\n\n// Webhook event types for each CRM\nexport const WEBHOOK_EVENTS = {\n  hubspot: [\n    'contact.creation',\n    'contact.deletion',\n    'contact.propertyChange',\n    'company.creation',\n    'company.deletion',\n    'company.propertyChange',\n    'deal.creation',\n    'deal.deletion',\n    'deal.propertyChange'\n  ],\n  salesforce: [\n    'Lead.created',\n    'Lead.updated',\n    'Lead.deleted',\n    'Contact.created',\n    'Contact.updated',\n    'Contact.deleted',\n    'Account.created',\n    'Account.updated',\n    'Account.deleted',\n    'Opportunity.created',\n    'Opportunity.updated',\n    'Opportunity.deleted'\n  ],\n  pipedrive: [\n    'person.added',\n    'person.updated',\n    'person.deleted',\n    'organization.added',\n    'organization.updated',\n    'organization.deleted',\n    'deal.added',\n    'deal.updated',\n    'deal.deleted'\n  ]\n};\n\nexport class CRMWebhookService {\n  private static instance: CRMWebhookService;\n  private processingQueue: Map<string, WebhookEvent[]> = new Map();\n  private isProcessing = false;\n\n  static getInstance(): CRMWebhookService {\n    if (!CRMWebhookService.instance) {\n      CRMWebhookService.instance = new CRMWebhookService();\n    }\n    return CRMWebhookService.instance;\n  }\n\n  /**\n   * Create a webhook for a CRM provider\n   */\n  async createWebhook(\n    userId: string,\n    provider: string,\n    eventType: string,\n    callbackUrl?: string\n  ): Promise<WebhookConfig> {\n    // Get OAuth tokens\n    const tokens = await crmOAuthService.getStoredTokens(userId, provider);\n    if (!tokens) {\n      throw new Error(`No valid OAuth tokens found for ${provider}`);\n    }\n\n    // Generate webhook URL if not provided\n    const webhookUrl = callbackUrl || `${window.location.origin}/api/webhooks/${provider}`;\n    \n    // Create webhook with the CRM provider\n    const webhookId = await this.createWebhookWithProvider(\n      provider,\n      eventType,\n      webhookUrl,\n      tokens.accessToken\n    );\n\n    // Store webhook configuration\n    const config: WebhookConfig = {\n      id: webhookId,\n      userId,\n      provider,\n      eventType,\n      callbackUrl: webhookUrl,\n      secret: this.generateWebhookSecret(),\n      isActive: true,\n      createdAt: new Date(),\n      triggerCount: 0,\n      errorCount: 0\n    };\n\n    await this.storeWebhookConfig(config);\n    return config;\n  }\n\n  /**\n   * Delete a webhook\n   */\n  async deleteWebhook(userId: string, webhookId: string): Promise<boolean> {\n    try {\n      // Get webhook configuration\n      const config = await this.getWebhookConfig(webhookId);\n      if (!config || config.userId !== userId) {\n        return false;\n      }\n\n      // Get OAuth tokens\n      const tokens = await crmOAuthService.getStoredTokens(userId, config.provider);\n      if (tokens) {\n        // Delete webhook from CRM provider\n        await this.deleteWebhookWithProvider(\n          config.provider,\n          webhookId,\n          tokens.accessToken\n        );\n      }\n\n      // Remove from storage\n      await this.removeWebhookConfig(webhookId);\n      return true;\n    } catch (error) {\n      console.error('Failed to delete webhook:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Process incoming webhook event\n   */\n  async processWebhookEvent(\n    provider: string,\n    payload: any,\n    signature?: string\n  ): Promise<WebhookProcessingResult> {\n    const startTime = Date.now();\n    const result: WebhookProcessingResult = {\n      success: false,\n      recordsProcessed: 0,\n      recordsCreated: 0,\n      recordsUpdated: 0,\n      errors: [],\n      duration: 0\n    };\n\n    try {\n      // Validate webhook signature\n      const isValid = await this.validateWebhookSignature(provider, payload, signature);\n      if (!isValid) {\n        result.errors.push('Invalid webhook signature');\n        return result;\n      }\n\n      // Parse webhook event\n      const events = this.parseWebhookPayload(provider, payload);\n      result.recordsProcessed = events.length;\n\n      // Process each event\n      for (const event of events) {\n        try {\n          const processed = await this.processIndividualEvent(provider, event);\n          if (processed.created) {\n            result.recordsCreated++;\n          } else if (processed.updated) {\n            result.recordsUpdated++;\n          }\n        } catch (error) {\n          result.errors.push(\n            `Failed to process event ${event.id}: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n        }\n      }\n\n      result.success = result.errors.length < result.recordsProcessed * 0.1; // Success if <10% errors\n    } catch (error) {\n      result.errors.push(\n        `Webhook processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n\n    result.duration = Date.now() - startTime;\n    \n    // Log webhook processing result\n    await this.logWebhookProcessing(provider, result);\n    \n    return result;\n  }\n\n  /**\n   * Get webhook configurations for a user\n   */\n  async getUserWebhooks(userId: string): Promise<WebhookConfig[]> {\n    try {\n      // In a real implementation, this would query a webhooks table\n      // For now, we'll use the user's custom branding field\n      const user = await blink.db.users.list({\n        where: { id: userId },\n        limit: 1\n      });\n\n      if (user.length === 0) {\n        return [];\n      }\n\n      const customBranding = user[0].customBranding;\n      if (!customBranding) {\n        return [];\n      }\n\n      const data = JSON.parse(customBranding);\n      return data.webhooks || [];\n    } catch (error) {\n      console.error('Failed to get user webhooks:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Update webhook status\n   */\n  async updateWebhookStatus(webhookId: string, isActive: boolean): Promise<boolean> {\n    try {\n      const config = await this.getWebhookConfig(webhookId);\n      if (!config) {\n        return false;\n      }\n\n      config.isActive = isActive;\n      await this.storeWebhookConfig(config);\n      return true;\n    } catch (error) {\n      console.error('Failed to update webhook status:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get webhook statistics\n   */\n  async getWebhookStats(userId: string): Promise<{\n    totalWebhooks: number;\n    activeWebhooks: number;\n    totalTriggers: number;\n    totalErrors: number;\n    lastTriggered?: Date;\n  }> {\n    const webhooks = await this.getUserWebhooks(userId);\n    \n    return {\n      totalWebhooks: webhooks.length,\n      activeWebhooks: webhooks.filter(w => w.isActive).length,\n      totalTriggers: webhooks.reduce((sum, w) => sum + w.triggerCount, 0),\n      totalErrors: webhooks.reduce((sum, w) => sum + w.errorCount, 0),\n      lastTriggered: webhooks\n        .filter(w => w.lastTriggered)\n        .sort((a, b) => (b.lastTriggered?.getTime() || 0) - (a.lastTriggered?.getTime() || 0))[0]?.lastTriggered\n    };\n  }\n\n  private async createWebhookWithProvider(\n    provider: string,\n    eventType: string,\n    callbackUrl: string,\n    accessToken: string\n  ): Promise<string> {\n    switch (provider) {\n      case 'hubspot':\n        return this.createHubSpotWebhook(eventType, callbackUrl, accessToken);\n      case 'salesforce':\n        return this.createSalesforceWebhook(eventType, callbackUrl, accessToken);\n      case 'pipedrive':\n        return this.createPipedriveWebhook(eventType, callbackUrl, accessToken);\n      default:\n        throw new Error(`Unsupported provider: ${provider}`);\n    }\n  }\n\n  private async createHubSpotWebhook(\n    eventType: string,\n    callbackUrl: string,\n    accessToken: string\n  ): Promise<string> {\n    const webhook = {\n      subscriptionDetails: {\n        subscriptionType: eventType,\n        propertyName: eventType.includes('propertyChange') ? 'email' : undefined\n      },\n      enabled: true,\n      webhookUrl: callbackUrl\n    };\n\n    const response = await fetch('https://api.hubapi.com/webhooks/v3/subscriptions', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(webhook)\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to create HubSpot webhook: ${error}`);\n    }\n\n    const result = await response.json();\n    return result.id.toString();\n  }\n\n  private async createSalesforceWebhook(\n    eventType: string,\n    callbackUrl: string,\n    accessToken: string\n  ): Promise<string> {\n    // Salesforce uses Platform Events or Streaming API\n    // This is a simplified implementation\n    const webhook = {\n      Name: `Svara_${eventType}_${Date.now()}`,\n      Url: callbackUrl,\n      Events: [eventType],\n      IsActive: true\n    };\n\n    const response = await fetch('https://api.salesforce.com/services/data/v52.0/sobjects/RemoteSiteSetting/', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(webhook)\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to create Salesforce webhook: ${error}`);\n    }\n\n    const result = await response.json();\n    return result.id;\n  }\n\n  private async createPipedriveWebhook(\n    eventType: string,\n    callbackUrl: string,\n    accessToken: string\n  ): Promise<string> {\n    const webhook = {\n      subscription_url: callbackUrl,\n      event_action: eventType,\n      event_object: eventType.split('.')[0],\n      user_id: 0, // All users\n      http_auth_user: '',\n      http_auth_password: ''\n    };\n\n    const response = await fetch(`https://api.pipedrive.com/v1/webhooks?api_token=${accessToken}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(webhook)\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to create Pipedrive webhook: ${error}`);\n    }\n\n    const result = await response.json();\n    return result.data.id.toString();\n  }\n\n  private async deleteWebhookWithProvider(\n    provider: string,\n    webhookId: string,\n    accessToken: string\n  ): Promise<void> {\n    let url = '';\n    let method = 'DELETE';\n\n    switch (provider) {\n      case 'hubspot':\n        url = `https://api.hubapi.com/webhooks/v3/subscriptions/${webhookId}`;\n        break;\n      case 'salesforce':\n        url = `https://api.salesforce.com/services/data/v52.0/sobjects/RemoteSiteSetting/${webhookId}`;\n        break;\n      case 'pipedrive':\n        url = `https://api.pipedrive.com/v1/webhooks/${webhookId}?api_token=${accessToken}`;\n        break;\n      default:\n        throw new Error(`Unsupported provider: ${provider}`);\n    }\n\n    const response = await fetch(url, {\n      method,\n      headers: {\n        'Authorization': provider !== 'pipedrive' ? `Bearer ${accessToken}` : undefined,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    if (!response.ok) {\n      console.warn(`Failed to delete webhook with ${provider}:`, response.statusText);\n    }\n  }\n\n  private async validateWebhookSignature(\n    provider: string,\n    payload: any,\n    signature?: string\n  ): Promise<boolean> {\n    // In a real implementation, this would validate the webhook signature\n    // using the provider's specific signature validation method\n    \n    // For now, we'll just check if signature exists for providers that require it\n    switch (provider) {\n      case 'hubspot':\n        // HubSpot uses X-HubSpot-Signature header\n        return !!signature;\n      case 'salesforce':\n        // Salesforce uses custom validation\n        return true;\n      case 'pipedrive':\n        // Pipedrive doesn't use signatures by default\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  private parseWebhookPayload(provider: string, payload: any): any[] {\n    switch (provider) {\n      case 'hubspot':\n        return payload.events || [payload];\n      case 'salesforce':\n        return payload.sobjects || [payload];\n      case 'pipedrive':\n        return [payload.current || payload];\n      default:\n        return [payload];\n    }\n  }\n\n  private async processIndividualEvent(\n    provider: string,\n    event: any\n  ): Promise<{ created: boolean; updated: boolean }> {\n    // This would contain the logic to sync the webhook event data\n    // with the Svara database\n    \n    // For now, we'll just log the event\n    console.log(`Processing ${provider} webhook event:`, event);\n    \n    // Return mock result\n    return {\n      created: Math.random() > 0.5,\n      updated: Math.random() > 0.5\n    };\n  }\n\n  private async storeWebhookConfig(config: WebhookConfig): Promise<void> {\n    try {\n      // Get current user data\n      const user = await blink.db.users.list({\n        where: { id: config.userId },\n        limit: 1\n      });\n\n      if (user.length === 0) {\n        throw new Error('User not found');\n      }\n\n      // Parse existing custom branding or create new\n      let customData: any = {};\n      if (user[0].customBranding) {\n        customData = JSON.parse(user[0].customBranding);\n      }\n\n      // Store webhook config\n      if (!customData.webhooks) {\n        customData.webhooks = [];\n      }\n\n      // Update existing or add new\n      const existingIndex = customData.webhooks.findIndex((w: WebhookConfig) => w.id === config.id);\n      if (existingIndex >= 0) {\n        customData.webhooks[existingIndex] = config;\n      } else {\n        customData.webhooks.push(config);\n      }\n\n      // Update user record\n      await blink.db.users.update(config.userId, {\n        customBranding: JSON.stringify(customData)\n      });\n    } catch (error) {\n      console.error('Failed to store webhook config:', error);\n      throw error;\n    }\n  }\n\n  private async getWebhookConfig(webhookId: string): Promise<WebhookConfig | null> {\n    try {\n      // This is inefficient but works for the demo\n      // In a real implementation, we'd have a proper webhooks table\n      const users = await blink.db.users.list({ limit: 1000 });\n      \n      for (const user of users) {\n        if (user.customBranding) {\n          const data = JSON.parse(user.customBranding);\n          const webhook = data.webhooks?.find((w: WebhookConfig) => w.id === webhookId);\n          if (webhook) {\n            return webhook;\n          }\n        }\n      }\n      \n      return null;\n    } catch (error) {\n      console.error('Failed to get webhook config:', error);\n      return null;\n    }\n  }\n\n  private async removeWebhookConfig(webhookId: string): Promise<void> {\n    try {\n      const config = await this.getWebhookConfig(webhookId);\n      if (!config) {\n        return;\n      }\n\n      const user = await blink.db.users.list({\n        where: { id: config.userId },\n        limit: 1\n      });\n\n      if (user.length === 0) {\n        return;\n      }\n\n      let customData: any = {};\n      if (user[0].customBranding) {\n        customData = JSON.parse(user[0].customBranding);\n      }\n\n      if (customData.webhooks) {\n        customData.webhooks = customData.webhooks.filter((w: WebhookConfig) => w.id !== webhookId);\n      }\n\n      await blink.db.users.update(config.userId, {\n        customBranding: JSON.stringify(customData)\n      });\n    } catch (error) {\n      console.error('Failed to remove webhook config:', error);\n    }\n  }\n\n  private async logWebhookProcessing(\n    provider: string,\n    result: WebhookProcessingResult\n  ): Promise<void> {\n    try {\n      await blink.db.apiUsageLogs.create({\n        id: `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        userId: 'system', // System user for webhook processing\n        apiProvider: provider,\n        endpoint: 'webhook_processing',\n        creditsUsed: result.recordsProcessed,\n        success: result.success ? 1 : 0,\n        errorMessage: result.errors.length > 0 ? JSON.stringify(result.errors) : undefined,\n        responseTime: result.duration\n      });\n    } catch (error) {\n      console.error('Failed to log webhook processing:', error);\n    }\n  }\n\n  private generateWebhookSecret(): string {\n    return 'whsec_' + Math.random().toString(36).substring(2, 15) + \n           Math.random().toString(36).substring(2, 15);\n  }\n}\n\n// Export singleton instance\nexport const crmWebhookService = CRMWebhookService.getInstance();\n"